# 经典排序算法

## 排序算法包含
|算法名称|类名|平均时间复杂度|说明|
-|-|-|-
|冒泡排序|BubbleSort|O(n*n)|原理属于交换排序|
|快速排序|QuickSort||
|桶排序(简化版)|BucketSort(Simple)||
|选择排序|SelectSort||
||||

### 冒泡排序
#### 基本思想
   > 每次比较两个相邻的元素，如果他们顺序错误，就将他们交换过来



#### 冒泡排序算法实现  
   ```java
    for(int i = 0;i<array.length;i++) {
		for (int j = 0;j<array.length-i-1;j++) {
			if (array[j]>array[j+1]) {
                int temp =0;    //设置临时存储功能的变量
				temp = array[j];
				array[j] = array[j+1];
				array[j+1] = temp;
			}
		}
	}
   ```  
   > `temp` 就是起到了这个临时变量的作用

#### 思考背景--无需额外变量变量交换两个数/变量的值
在对经典排序算法进行复习的时候，发现排序算法对数组队列等数组结构中元素的操作大几率会用到交换两个变量的值(在逻辑上表现为交换两个元素的位置)，基础操作会是在额外声明一个新变量用于辅助交换元素的临时存值空间，比如
要想做到不使用临时变量存储对两个数进行位置互换(逻辑上)，是不是可以通过数学关系上两者的运算来达到这个效果，以下对此优化，做到不使用额外的变量空间置换两个数

#### 优化方法1：   
   算数运算(加减)
   ```java
    x=x+y; //x暂存两数之和
    y=x-y; //y为两数之和减去y，即原来的x
    x=x-y; //x为两数之和减去现在的y（原来的x），变成原来的y
   ```  
    以上对纯数字的值进行操作符合数学关系

    把 `x` 看成`array[j]`,`y` 看成`array[j+1]`,将核心代码优化一下
   ```java
    array[j] = array[j]+array[j+1];
    array[j+1] = array[j] - array[j+1];
    array[j] = array[j] - array[j+1];
   ```
    **实际上可读性就可能很牵强了**
#### 优化方法2：
    逻辑运算(异或)
   ```java
    x^=y;//x先存x和y两者的信息
    y^=x;//保持x不变，利用x异或反转y的原始值使其等于x的原始值
    x^=y;//保持y不变，利用x异或反转y的原始值使其等于y的原始值
   ```
    同理将核心代码优化结果
   ```java
    array[j] ^= array[j+1];
    array[j+1] ^= array[j];
    array[j] ^= array[j+1];
   ```
    **可读性可能也是差强人意**

**以上只是对方法的探讨。**


### 快速排序
  + 基于 `二分` 的思想

#### 快速排序算法实现
  + C 实现版本(数组版本)
    ```c
    static void QuickSort(int left, int right, int a[]) {
		if (left > right)
			return;

		int i, j, t, temp;
		temp = a[left]; // temp 就是保存基准数的
		i = left; // 用于标记比基准数大的数组元素的索引,首先初始化到序列最左侧
		j = right; // 用于标记比基准数小的数组元素的索引,首先初始化到序列最右侧

		while (i != j) { // 当 i和j还未相遇时，比较操作不会终止

			// 先从右侧开始遍历比较
			while (a[j] >= temp &&i<j) {
				j--;
			}

			while (a[i] <= temp &&i<j) {
				i++;
			}
			
			if (i < j) {
				// 循环操作数已经终止 接下来进行交换数位置的操作
				t = a[i];
				a[i] = a[j];
				a[j] = t;
			}

		}
		// 当i与 j相遇，接下来进行i,j所在的位置作为新的基准数，原来的基准数放入a[i]的位置(基准数归位)
		a[left] = a[i];
		a[i] = temp;
		//
		QuickSort(left, i - 1, a);
		QuickSort(i + 1, right, a);
	}
    ```

### 简化版桶排序
  + 假设一组自然数，我们已知这组数的最大值和最小值
  + 我们将会设立一个长度略大于这组数最大值的数组
  + 遍历这个数组，将每个元素的数值与数组索引值相同的数组元素+1(表示个数+1)
  + 遍历结束以后，可以根绝升序还是降序的要求进行顺序或者逆序打印数组里不为0的索引值，每个数组元素的值多大，该数组元素对应的索引值就重复打印多少次

#### “简化版桶排序” 算法实现   
   + 命题  
     输入一组数(已知是0~9的自然数)：  
        > 5 3 5 2 8   

     使用简化版的桶排序将该组数降序输出

   + C 实现版本  

     ```C
     #include <stdio.h>

     int main(){
         int a[11],i,j,t;
         for (i =;i<=10;i++){
             a[i]=0;
         }

         // 接下来循环读入 5 个数
         for(i=1;i<=5;i++){
             scanf("%d",&t);
             a[t]++;
         }

         for(i = 0;i<10;i++){
             for (j=1;j<=a[i];j++){
                 printf("%d",i)
             }
         }
         getchar();getchar();
         // 这里的getchar();可以用来暂停程序，以便查看输出内容
         // 也可以用 system("pause");
         return 0;
     }
     ```  

##### 简化版桶排序算法实际解题
  > 输入有 2 行，第 1 行为一个正整数，表示有 n 个同学参与调查(n≤100)。第 2 行有 n个用空格隔开的正整数，为每本图书的 ISBN 号(假设图书的 ISBN 号在 1~1000 之间)。请将其`去重`和`排序`  

  + 方法1：先将数据去重，然后从小到大排序输出  
    **解法**  *(C语言)*  
    将简化版的桶排序进行修改即可实现解题算法。  

    ```c
     #include <stdio.h>

     int main(){
       int a[1001],n,i,t;
       for(i = 0;i<1001;i++){
         a[i]=0;
       }
       scanf("%d",&n);  // 之后输入数字的个数
       for(i = 1,i<=n;i++){
         scanf("%d",&t);
         a[t]= 1; // 数据去重，我们只在乎该数是否出现过
       }

       for (i=1;i<=n;i++){
         if (a[i] == 1){
           printf("%d",i); // 在输出的时候进行过去重
         }
       }
       getchar();getchar();
       return 0;
     }
    ```  
    > 时间复杂度为 O(N+M)  


  + 方法2：先从小到大进行排序，然后在输出的时候去重  
    - **排序可以使用冒泡排序或者快速排序**  
    - **输出的时候只要两两相比较即可，不同就输出，相同就不输出**  
      ```c
       #include <stdio.h>

       int main(){
        int a[1001],n,i,j,t;
        for(i = 0;i<1001;i++){
          a[i]=0;
        }
        scanf("%d",&n);  // 之后输入数字的个数
        for(i = 1,i<=n;i++){
          scanf("%d",&a[i]);
        }

        //开始冒泡排序
        for(i=1;i<=n;i++){
          for(j=1;j<=n-i;j++){
            if(a[j-1]>a[j]){
              t= a[j-1];
              a[j-1]=a[j];
              a[j]=t;
            }
          }
        }

        // 开始在输出时去重
        for(i=1;i<=n-1;i++){
          if(a[i]!=a[i+1]){
            printf("%d",a[i]);
          }
        }
        getchar();getchar();
        return 0;
        }
      ```  
      > 实现算法的时间复杂度为O(n*n)  

### 选择排序  
  > 首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕

#### 选择排序的实现(数据源为顺序数组)  

  + ```c

    ```


#### Extra.
  + swap()函数：在 C 中起到的是交换值的作用